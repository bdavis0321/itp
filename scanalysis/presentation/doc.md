The SuperCollider code I've chosen to analyze is less of a musical piece and more of a tool, but still useful and interesting nonetheless. Written by Paul Miller as a response to a question from someone in his mailing list, it's code for creating and testing impulse responses for convolution reverb in SuperCollider.

It can load an IR from the user's disk (and play it forwards or backwards) as well as synthesizing a new IR using the dust and noise generators, and it can convolve these IRs with either a sound file loaded from disk OR live sound input, both of these can be delayed for use with reverse reverb.

Upon booting the server and evaluating the code, it clears any buffers that may have been active before, and loads a sound file from the disk into the a.target buffer for use later on. First, we either create an IR (EX1), load an IR from disk (EX2), or load an IR from disk and reverse it (EX3). EX2 is pretty simple as it just loads into the buffer from the given file path. EX3 is the same thing, but it also loads the buffer into a floatArray and reverses it. 

EX1 is a lot more fun, giving you a lot of freedom to customize a new IR using the Dust.ar generator. You start by specifying how long you want the IR to be in seconds (a.bufferTime), the density/reflections (a.densityMin/Max), and the minimum and maximum frequency for the filter sweep (a.filterFreqMin/Max). Using the variables sourceVolEnv (the volume/amp envelope using a.bufferTime), filterFreqEnv (the filter envelope using the a.filterFreqMin/Max), densityEnv (the density envelope using a.densityMin/Max), source, filterFunc, and outSound. The source variable uses the Dust generator, setting the density to the densityEnv variable and multipling it by 0.5, then multipling that by a noise generator (currently set to WhiteNoise.ar). The filterFunc variable uses the LPF.ar set to the input plus an allpass filter. The outSound variable sets the filterFunc value to the sourceVolEnv multiplied by the source variable, which is then multiplied by 100 and divided by the densityEnv variable. Finally, the buffer is recorded using BufWr.ar using that outSound variable. 

Before anything can be convolved, the a.irspectrum buffer is made using the PartConv UGen and the a.buffer from EX1/2/3.

The IR you use with EX1/2/3 can then be convolved with either the target soundfile you loaded earlier into the a.target buffer or a live input. Starting with just the target by itself, the variables input and convLevel are created, convLevel being set to 0.1 currently. The input variable uses the PlayBuf.ar UGen with one channel in mono, and the a.target can be looped or not. Using Out.ar, the PartConv.ar UGen (real-time convolution) convolves the input with the a.irspectrum buffer, and multiplies this by the specified convLevel. Doing it this way only gives the wet signal, so in order to add any dry signal, we introduce the delayTime, inputDelay, and inputLevel variables, inputLevel (the dry signal) being set to 0.3 currently. It works the exact same way except this time, we add the dry signal (inputLevel * input) to the wet signal (convLevel * partConv.ar) at Out.ar. 

In EX3 we saw that we can reverse the IR loaded from disk to create a reverse reverb effect. We could use this IR as we would a normal one, however we also have the option to delay the dry input signal until the tail of the reversed IR ends. We do this by setting delayTime to the number of frames in a.buffer (BufFrames.ir) divided by the sample rate of a.buffer (BufSampleRate.ir). The inputDelay variable is set to the DelayC.ar UGen, which just takes the dry signal from before (inputLevel * input) and delaying it by the time set in delayTime. Now, the inputDelay variable is used in place of the original dry signal in Out.ar.

Convolving the live input works the exact same as the target soundfile, but we just replace the PlayBuf.ar with the SoundIn.ar UGen. From here, everything else works the exact same when it comes to convolving the signal using PartConv, delaying the input, adding the dry signal, etc. 

Overall, it's a very simple piece of code that can be a tool to show how convolution reverb can be implemented into your projects in many different ways, and it definitely makes that process seem a lot easier than it did before.